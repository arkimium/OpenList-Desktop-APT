name: Build and Upload DEB Package

on:
  schedule:
    # Run daily at 2 AM UTC to check for new releases (updated)
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      force_build:
        description: 'Force build even if no new version'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write

jobs:
  check-version:
    name: Check OpenList Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      tag_name: ${{ steps.get-version.outputs.tag_name }}
      should_build: ${{ steps.check-build.outputs.should_build }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Get latest OpenList release
      id: get-version
      run: |
        echo "=== Fetching latest release from OpenListTeam/OpenList ==="
        
        # Get latest release info from OpenList repository
        RELEASE_INFO=$(curl -s "https://api.github.com/repos/OpenListTeam/OpenList/releases/latest")
        
        echo "API Response:"
        echo "$RELEASE_INFO" | jq '.' || echo "Failed to parse JSON response"
        
        # Extract version and tag name with better error handling
        TAG_NAME=$(echo "$RELEASE_INFO" | jq -r '.tag_name // empty')
        
        if [ -z "$TAG_NAME" ] || [ "$TAG_NAME" = "null" ] || [ "$TAG_NAME" = "empty" ]; then
          echo "Error: Failed to get tag_name from API response"
          echo "Trying alternative approach..."
          
          # Try to get the first release if latest fails
          RELEASE_INFO=$(curl -s "https://api.github.com/repos/OpenListTeam/OpenList/releases" | jq '.[0]')
          TAG_NAME=$(echo "$RELEASE_INFO" | jq -r '.tag_name // empty')
          
          if [ -z "$TAG_NAME" ] || [ "$TAG_NAME" = "null" ] || [ "$TAG_NAME" = "empty" ]; then
            echo "Error: Still failed to get tag_name"
            echo "Using fallback version"
            TAG_NAME="v1.0.0"
          fi
        fi
        
        # Remove 'v' prefix if present
        VERSION=${TAG_NAME#v}
        
        # Ensure version is clean (no 'v' prefix)
        VERSION=$(echo "$VERSION" | sed 's/^v//')
        
        # Validate version format
        if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
          echo "Warning: Version format seems invalid: $VERSION"
          echo "Using fallback version"
          VERSION="1.0.0"
          TAG_NAME="v1.0.0"
        fi
        
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Latest OpenList version: $VERSION (tag: $TAG_NAME)"
        
    - name: Check if build is needed
      id: check-build
      run: |
        VERSION="${{ steps.get-version.outputs.version }}"
        FORCE_BUILD="${{ github.event.inputs.force_build }}"
        
        echo "Checking if build is needed for version: $VERSION"
        
        # Check if this version was already built
        if [ "$FORCE_BUILD" = "true" ]; then
          echo "Force build requested"
          echo "should_build=true" >> $GITHUB_OUTPUT
        else
          # Check if release with this version already exists in current repo
          EXISTING_RELEASE=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/tags/v$VERSION" | jq -r '.tag_name // empty')
          
          if [ -z "$EXISTING_RELEASE" ] || [ "$EXISTING_RELEASE" = "empty" ]; then
            echo "Version $VERSION not found in releases, building..."
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "Version $VERSION already exists, skipping build"
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi
        fi

  build-deb:
    name: Build OpenList Packages
    needs: check-version
    if: needs.check-version.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [amd64, arm64]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up build environment
      run: |
        sudo apt-get update
        sudo apt-get install -y debhelper devscripts build-essential wget jq
        
        # Install cross-compilation tools for ARM64 if needed
        if [ "${{ matrix.arch }}" = "arm64" ]; then
          sudo apt-get install -y gcc-aarch64-linux-gnu
        fi
        
    - name: Prepare and build DEB package
      run: |
        VERSION="${{ needs.check-version.outputs.version }}"
        TAG_NAME="${{ needs.check-version.outputs.tag_name }}"
        ARCH="${{ matrix.arch }}"
        
        # Validate inputs
        if [ -z "$VERSION" ] || [ "$VERSION" = "null" ]; then
          echo "Error: VERSION is null or empty"
          exit 1
        fi
        
        if [ -z "$TAG_NAME" ] || [ "$TAG_NAME" = "null" ]; then
          echo "Error: TAG_NAME is null or empty"
          exit 1
        fi
        
        # Ensure version is clean (no 'v' prefix) for debian package
        CLEAN_VERSION=$(echo "$VERSION" | sed 's/^v//')
        
        echo "=== Version Information ==="
        echo "Original TAG_NAME: $TAG_NAME"
        echo "Extracted VERSION: $VERSION"
        echo "Clean VERSION for debian: $CLEAN_VERSION"
        echo "Architecture: $ARCH"
        
        # Validate clean version
        if [[ ! "$CLEAN_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
          echo "Error: Clean version format is invalid: $CLEAN_VERSION"
          exit 1
        fi
        
        echo "=== Preparing debian package ==="
        
        # Update changelog with clean version (no 'v' prefix)
        cat > debian/changelog << EOF
        openlist ($CLEAN_VERSION-1) unstable; urgency=medium

          * DEB package built from OpenListTeam/OpenList $TAG_NAME
          * Automated build for $ARCH architecture
          * Binary downloaded from official release

         -- OpenList Team <openlistteam@gmail.com>  $(date -R)
        EOF
        
        echo "Generated changelog:"
        cat debian/changelog
        
        # Make scripts executable
        chmod +x debian/rules
        chmod +x debian/postinst
        chmod +x debian/prerm
        chmod +x debian/postrm
        
        echo "=== Pre-downloading binary (optional, debian/rules will download if missing) ==="
        
        # Try to pre-download the binary to speed up build
        DOWNLOAD_URL="https://github.com/OpenListTeam/OpenList/releases/download/$TAG_NAME/openlist-linux-$ARCH.tar.gz"
        echo "Pre-download URL: $DOWNLOAD_URL"
        
        if wget -O "openlist-linux-$ARCH.tar.gz" "$DOWNLOAD_URL" 2>/dev/null; then
          echo "Pre-download successful"
          ls -la openlist-linux-$ARCH.tar.gz
        else
          echo "Pre-download failed, debian/rules will handle download"
        fi
        
        echo "=== Building DEB package ==="
        
        # Set environment variables for cross-compilation
        export DEB_HOST_ARCH=$ARCH
        export DEB_BUILD_OPTIONS="nocheck"
        
        # Set cross-compilation environment for ARM64
        if [ "$ARCH" = "arm64" ]; then
          export CC=aarch64-linux-gnu-gcc
          export DEB_BUILD_PROFILES="cross"
        fi
        
        echo "Building package with:"
        echo "DEB_HOST_ARCH=$DEB_HOST_ARCH"
        echo "DEB_BUILD_OPTIONS=$DEB_BUILD_OPTIONS"
        echo "CC=$CC"
        echo "DEB_BUILD_PROFILES=$DEB_BUILD_PROFILES"
        echo "Package version: $CLEAN_VERSION-1"
        
        # Verify current directory before build
        echo "Files in current directory before build:"
        ls -la
        
        # Build the package
        dpkg-buildpackage -us -uc -a$ARCH
        
        echo "=== Build completed ==="
        echo "Generated files:"
        ls -la ../*.deb || echo "No .deb files found in parent directory"
        ls -la *.deb || echo "No .deb files found in current directory"
        
        # The package should be named with the clean version
        EXPECTED_DEB="openlist_${CLEAN_VERSION}-1_${ARCH}.deb"
        if [ -f "$EXPECTED_DEB" ]; then
          echo "Successfully built: $EXPECTED_DEB"
        elif [ -f "../$EXPECTED_DEB" ]; then
          echo "Successfully built: ../$EXPECTED_DEB"
          mv "../$EXPECTED_DEB" "./"
        else
          echo "Warning: Expected DEB file not found: $EXPECTED_DEB"
          echo "Available DEB files:"
          find . -name "*.deb" -o -name "../*.deb"
        fi
        
    - name: Upload DEB artifact to build assets
      uses: actions/upload-artifact@v4
      with:
        name: openlist-${{ needs.check-version.outputs.version }}-${{ matrix.arch }}.deb
        path: openlist_${{ needs.check-version.outputs.version }}-1_${{ matrix.arch }}.deb
        retention-days: 90
        
  create-release:
    name: Create Github Release
    needs: [check-version, build-deb]
    if: needs.check-version.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      
    - name: Set up APT repository tools
      run: |
        sudo apt-get update
        sudo apt-get install -y apt-utils gnupg2
        
    - name: Set up GPG for signing
      env:
        GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
      run: |
        if [ -n "$GPG_PRIVATE_KEY" ]; then
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          echo "use-agent" >> ~/.gnupg/gpg.conf
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          echo RELOADAGENT | gpg-connect-agent
          
          # Get GPG key ID
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -1 | sed 's/.*\/\([A-F0-9]*\).*/\1/')
          echo "GPG_KEY_ID=$GPG_KEY_ID" >> $GITHUB_ENV
          echo "GPG signing enabled with key: $GPG_KEY_ID"
        else
          echo "No GPG key provided, repository will be unsigned"
          echo "GPG_KEY_ID=" >> $GITHUB_ENV
        fi
        
    - name: Generate APT repository files
      run: |
        VERSION="${{ needs.check-version.outputs.version }}"
        
        # Create working directory
        mkdir -p apt-repo
        cd apt-repo
        
        # Copy DEB files
        cp ../openlist-$VERSION-amd64.deb/openlist_${VERSION}-1_amd64.deb .
        cp ../openlist-$VERSION-arm64.deb/openlist_${VERSION}-1_arm64.deb .
        
        echo "DEB files for APT repository:"
        ls -la *.deb
        
        # Create apt-ftparchive configuration
        cat > apt-ftparchive.conf << EOF
        APT::FTPArchive::Release::Origin "OpenList";
        APT::FTPArchive::Release::Label "OpenList APT Repository";
        APT::FTPArchive::Release::Suite "./";
        APT::FTPArchive::Release::Codename "openlist";
        APT::FTPArchive::Release::Architectures "amd64 arm64";
        APT::FTPArchive::Release::Components "";
        APT::FTPArchive::Release::Description "OpenList APT Repository for direct GitHub Release access";
        EOF
        
        # Generate Packages file using apt-ftparchive
        apt-ftparchive packages . > Packages
        
        echo "Generated Packages file with $(grep -c '^Package:' Packages) packages"
        
        # Generate Release file using apt-ftparchive
        apt-ftparchive -c apt-ftparchive.conf release . > Release
        
        echo "Generated Release file:"
        cat Release
        
    - name: Sign Release file and create keyring
      env:
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
      run: |
        cd apt-repo
        
        if [ -n "$GPG_KEY_ID" ]; then
          echo "Signing Release file with GPG key: $GPG_KEY_ID"
          
          # Sign Release file (detached signature)
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
              --armor --detach-sign --sign -o Release.gpg Release
          
          # Create InRelease file (clearsigned)
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
              --armor --clearsign --sign -o InRelease Release
          
          echo "Release file signed successfully"
          
          # Export public key and create keyring file
          echo "Creating GPG keyring file..."
          gpg --batch --yes --armor --export "$GPG_KEY_ID" > openlist-archive-keyring.asc
          gpg --batch --yes --dearmor < openlist-archive-keyring.asc > openlist-archive-keyring.gpg
          
          # Verify keyring file
          if [ -f "openlist-archive-keyring.gpg" ] && [ -s "openlist-archive-keyring.gpg" ]; then
            echo "GPG keyring file created successfully"
            ls -la openlist-archive-keyring.*
          else
            echo "Warning: Failed to create GPG keyring file"
          fi
          
          ls -la Release*
        else
          echo "No GPG key available, skipping signing and keyring creation"
        fi
        
    - name: Create installation script
      run: |
        cd apt-repo
        
        # Create installation script
        cat > install-apt.sh << 'EOF'
        #!/bin/bash
        set -e

        # Color definitions for better output
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        BLUE='\033[0;34m'
        PURPLE='\033[0;35m'
        CYAN='\033[0;36m'
        WHITE='\033[1;37m'
        NC='\033[0m' # No Color

        # Logging functions with colors
        log() {
            local message="$1"
            local level="${2:-info}"
            case "$level" in
                "error")
                    echo -e "${RED}[ERROR]${NC} $message" >&2
                    ;;
                "success")
                    echo -e "${GREEN}[SUCCESS]${NC} $message"
                    ;;
                "warning")
                    echo -e "${YELLOW}[WARNING]${NC} $message"
                    ;;
                "info")
                    echo -e "${BLUE}[INFO]${NC} $message"
                    ;;
                *)
                    echo -e "${WHITE}[LOG]${NC} $message"
                    ;;
            esac
        }

        # Error handling function
        handle_error() {
            local exit_code="$1"
            local error_message="$2"
            log "$error_message" "error"
            log "Exit code: $exit_code" "error"
            exit $exit_code
        }

        echo -e "${CYAN}=== OpenList APT Repository Setup ===${NC}"

        # Detect if running as root
        if [ "$EUID" -eq 0 ]; then
            log "Running as root user" "info"
            SUDO_CMD=""
        else
            log "Running as regular user, will use sudo when needed" "info"
            SUDO_CMD="sudo"
        fi

        # Detect system
        if command -v lsb_release &> /dev/null; then
            DISTRO=$(lsb_release -si)
            VERSION=$(lsb_release -sr)
            log "Detected: $DISTRO $VERSION" "info"
        else
            log "Cannot detect system version, using legacy format" "warning"
            DISTRO="Unknown"
            VERSION="0"
        fi

        # Install required packages for GPG key handling
        log "Installing required packages..." "info"
        if ! $SUDO_CMD apt-get update -qq; then
            handle_error "$?" "Failed to update package list"
        fi

        if ! $SUDO_CMD apt-get install -y -qq curl gnupg2 ca-certificates; then
            handle_error "$?" "Failed to install required packages"
        fi

        # Add GPG key to resolve signature verification issues
        log "Adding OpenList repository GPG key..." "info"
        KEYRING_URL="https://github.com/GITHUB_REPO/releases/latest/download/openlist-archive-keyring.gpg"
        KEYRING_PATH="/usr/share/keyrings/openlist-archive-keyring.gpg"
        
        # Try to download the pre-generated keyring file
        if curl -fsSL "$KEYRING_URL" -o /tmp/openlist-archive-keyring.gpg 2>/dev/null; then
            # Verify the downloaded file is not empty and is a valid GPG keyring
            if [ -s /tmp/openlist-archive-keyring.gpg ]; then
                $SUDO_CMD mv /tmp/openlist-archive-keyring.gpg "$KEYRING_PATH"
                $SUDO_CMD chmod 644 "$KEYRING_PATH"
                log "GPG keyring downloaded and installed successfully" "success"
            else
                log "Downloaded keyring file is empty, falling back to trusted repository" "warning"
                rm -f /tmp/openlist-archive-keyring.gpg
                $SUDO_CMD touch "$KEYRING_PATH"
            fi
        else
            log "Could not download GPG keyring from repository, creating trusted repository entry" "warning"
            # Create a dummy keyring file to avoid errors
            $SUDO_CMD touch "$KEYRING_PATH"
        fi

        # Choose sources format based on system
        if [[ "$DISTRO" == "Ubuntu" && $(echo "$VERSION >= 22.04" | bc -l 2>/dev/null || echo 0) -eq 1 ]] || \
           [[ "$DISTRO" == "Debian" && $(echo "$VERSION >= 12" | bc -l 2>/dev/null || echo 0) -eq 1 ]]; then
            log "Using modern sources format..." "info"
            
            # Use signed-by for modern systems, but fall back to trusted=yes if GPG key is not available
            if [ -s /usr/share/keyrings/openlist-archive-keyring.gpg ]; then
                echo 'Types: deb
        URIs: https://github.com/GITHUB_REPO/releases/latest/download/
        Suites: ./
        Signed-By: /usr/share/keyrings/openlist-archive-keyring.gpg' | $SUDO_CMD tee /etc/apt/sources.list.d/openlist.sources > /dev/null
            else
                echo 'Types: deb
        URIs: https://github.com/GITHUB_REPO/releases/latest/download/
        Suites: ./
        Trusted: yes' | $SUDO_CMD tee /etc/apt/sources.list.d/openlist.sources > /dev/null
            fi
        else
            log "Using legacy sources format..." "info"
            
            # Use signed-by for legacy systems, but fall back to trusted=yes if GPG key is not available
            if [ -s /usr/share/keyrings/openlist-archive-keyring.gpg ]; then
                echo 'deb [signed-by=/usr/share/keyrings/openlist-archive-keyring.gpg] https://github.com/GITHUB_REPO/releases/latest/download/ ./' | $SUDO_CMD tee /etc/apt/sources.list.d/openlist.list > /dev/null
            else
                echo 'deb [trusted=yes] https://github.com/GITHUB_REPO/releases/latest/download/ ./' | $SUDO_CMD tee /etc/apt/sources.list.d/openlist.list > /dev/null
            fi
        fi

        log "Repository configuration added successfully" "success"

        # Run 'apt-get update'
        log "Updating package list..." "info"
        if ! $SUDO_CMD apt-get update -y; then
            handle_error "$?" "Failed to run 'apt-get update'"
        else
            log "Repository configured successfully." "success"
            echo ""
            log "To install OpenList, run: ${WHITE}apt-get install openlist -y${NC}" "info"
            log "You can also use the following commands:" "info"
            echo ""
            echo -e "${PURPLE}Installation:${NC}"
            if [ "$EUID" -eq 0 ]; then
                echo -e "  ${WHITE}apt-get install openlist -y${NC}          # Install OpenList"
            else
                echo -e "  ${WHITE}sudo apt-get install openlist -y${NC}     # Install OpenList"
            fi
            echo ""
            echo -e "${PURPLE}Service Management (after installation):${NC}"
            if [ "$EUID" -eq 0 ]; then
                echo -e "  ${WHITE}systemctl status openlist${NC}            # Check status"
                echo -e "  ${WHITE}systemctl start openlist${NC}             # Start service"
                echo -e "  ${WHITE}systemctl stop openlist${NC}              # Stop service"
                echo -e "  ${WHITE}systemctl restart openlist${NC}           # Restart service"
                echo -e "  ${WHITE}journalctl -u openlist -f${NC}            # View logs"
            else
                echo -e "  ${WHITE}sudo systemctl status openlist${NC}       # Check status"
                echo -e "  ${WHITE}sudo systemctl start openlist${NC}        # Start service"
                echo -e "  ${WHITE}sudo systemctl stop openlist${NC}         # Stop service"
                echo -e "  ${WHITE}sudo systemctl restart openlist${NC}      # Restart service"
                echo -e "  ${WHITE}sudo journalctl -u openlist -f${NC}       # View logs"
            fi
            echo ""
            echo -e "${PURPLE}Command Line Access (after installation):${NC}"
            echo -e "  ${WHITE}openlist --help${NC}                       # Show help"
            echo -e "  ${WHITE}openlist version${NC}                      # Show version"
            echo ""
            echo -e "${PURPLE}Configuration and Data Location:${NC}"
            echo -e "  ${WHITE}/var/lib/openlist${NC}"
            echo ""
        fi
        EOF
        
        # Replace placeholder with actual repository
        sed -i "s|GITHUB_REPO|${{ github.repository }}|g" install-apt.sh
        chmod +x install-apt.sh

        echo "Created installation script"
        
    - name: Create GitHub Release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        VERSION="${{ needs.check-version.outputs.version }}"
        TAG_NAME="v$VERSION"
        SOURCE_TAG="${{ needs.check-version.outputs.tag_name }}"
        
        # Prepare files for upload
        cd apt-repo
        FILES_TO_UPLOAD="Packages Release install-apt.sh"
        
        # Add signed files if they exist
        if [ -f "Release.gpg" ]; then
          FILES_TO_UPLOAD="$FILES_TO_UPLOAD Release.gpg InRelease"
        fi
        
        # Add keyring file if it exists
        if [ -f "openlist-archive-keyring.gpg" ]; then
          FILES_TO_UPLOAD="$FILES_TO_UPLOAD openlist-archive-keyring.gpg"
        fi
        
        cd ..
        
        # Create release with proper changelog
        gh release create "$TAG_NAME" \
          --title "OpenList DEB Package $VERSION" \
          --notes "## DEB Package for OpenList $VERSION

        This is an automated DEB package build from [OpenListTeam/OpenList $SOURCE_TAG](https://github.com/OpenListTeam/OpenList/releases/tag/$SOURCE_TAG).

        ### üì¶ Package Information
        - **Source**: OpenListTeam/OpenList $SOURCE_TAG
        - **Package Version**: $VERSION-1
        - **Build Date**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        - **Architectures**: AMD64, ARM64
        - **GPG Signed**: $([ -f apt-repo/Release.gpg ] && echo '‚úÖ Yes' || echo '‚ùå No')
        - **Repository Format**: APT-compatible with GPG signature verification

        ### üöÄ Installation

        #### üéØ APT Repository (Recommended - Automatic GPG Setup)
        \`\`\`bash
        # One-line install with automatic GPG key setup
        curl -fsSL https://github.com/${{ github.repository }}/releases/latest/download/install-apt.sh | bash
        
        # Then install OpenList
        sudo apt install openlist -y
        \`\`\`

        #### üì¶ PPA Repository (Alternative - Launchpad)
        \`\`\`bash
        # Add PPA repository
        sudo add-apt-repository ppa:openlist/server
        sudo apt update
        
        # Install OpenList
        sudo apt install openlist -y
        \`\`\`

        #### üîê Manual APT Setup with GPG Verification (Modern systems - Ubuntu 22.04+/Debian 12+)
        \`\`\`bash
        # Download and install GPG keyring
        curl -fsSL https://github.com/${{ github.repository }}/releases/latest/download/openlist-archive-keyring.gpg | \\
          sudo tee /usr/share/keyrings/openlist-archive-keyring.gpg > /dev/null

        # Add repository with GPG verification
        echo \"Types: deb
        URIs: https://github.com/${{ github.repository }}/releases/latest/download/
        Suites: ./
        Signed-By: /usr/share/keyrings/openlist-archive-keyring.gpg\" | \\
          sudo tee /etc/apt/sources.list.d/openlist.sources

        # Update and install
        sudo apt update && sudo apt install openlist -y
        \`\`\`

        #### üîê Manual APT Setup with GPG Verification (Legacy systems - Ubuntu <22.04/Debian <12)
        \`\`\`bash
        # Download and install GPG keyring
        curl -fsSL https://github.com/${{ github.repository }}/releases/latest/download/openlist-archive-keyring.gpg | \\
          sudo tee /usr/share/keyrings/openlist-archive-keyring.gpg > /dev/null

        # Add repository with GPG verification
        echo \"deb [signed-by=/usr/share/keyrings/openlist-archive-keyring.gpg] https://github.com/${{ github.repository }}/releases/latest/download/ ./\" | \\
          sudo tee /etc/apt/sources.list.d/openlist.list

        # Update and install
        sudo apt update && sudo apt install openlist -y
        \`\`\`

        #### ‚ö†Ô∏è Manual APT Setup without GPG Verification (Not Recommended)
        \`\`\`bash
        # Modern systems (Ubuntu 22.04+/Debian 12+)
        echo \"Types: deb
        URIs: https://github.com/${{ github.repository }}/releases/latest/download/
        Suites: ./
        Trusted: yes\" | sudo tee /etc/apt/sources.list.d/openlist.sources

        # Legacy systems (Ubuntu <22.04/Debian <12)
        echo \"deb [trusted=yes] https://github.com/${{ github.repository }}/releases/latest/download/ ./\" | \\
          sudo tee /etc/apt/sources.list.d/openlist.list

        # Update and install
        sudo apt update && sudo apt install openlist -y
        \`\`\`

        #### üì¶ Direct Download (AMD64)
        \`\`\`bash
        wget https://github.com/${{ github.repository }}/releases/download/$TAG_NAME/openlist_${VERSION}-1_amd64.deb
        sudo dpkg -i openlist_${VERSION}-1_amd64.deb
        sudo apt-get install -f  # Fix any dependency issues
        \`\`\`

        #### üì¶ Direct Download (ARM64)
        \`\`\`bash
        wget https://github.com/${{ github.repository }}/releases/download/$TAG_NAME/openlist_${VERSION}-1_arm64.deb
        sudo dpkg -i openlist_${VERSION}-1_arm64.deb
        sudo apt-get install -f  # Fix any dependency issues
        \`\`\`

        ### üîê GPG Key Information
        - **GPG Signed**: $([ -f apt-repo/Release.gpg ] && echo 'Yes' || echo 'No')
        - **Keyring File**: [openlist-archive-keyring.gpg](https://github.com/${{ github.repository }}/releases/latest/download/openlist-archive-keyring.gpg)
        - **Verification**: Repository packages are cryptographically signed for security

        ### üîß Service Management
        \`\`\`bash
        # Check service status
        sudo systemctl status openlist

        # Start/stop/restart service
        sudo systemctl start openlist
        sudo systemctl stop openlist
        sudo systemctl restart openlist

        # Enable/disable auto-start
        sudo systemctl enable openlist   # Start on boot
        sudo systemctl disable openlist  # Don't start on boot

        # View logs
        sudo journalctl -u openlist -f
        sudo journalctl -u openlist --since \"1 hour ago\"
        \`\`\`

        ### üìÅ File Locations
        - **Binary**: \`/var/lib/openlist/openlist\`
        - **Working Directory**: \`/var/lib/openlist\`
        - **Service File**: \`/usr/lib/systemd/system/openlist.service\`
        - **Command Symlink**: \`/usr/bin/openlist\`
        - **Configuration**: \`/var/lib/openlist/\` (auto-generated)
        - **Logs**: \`journalctl -u openlist\` or \`/var/log/syslog\`

        ### üîç Verification
        \`\`\`bash
        # Verify installation
        openlist --version
        systemctl is-active openlist
        
        # Check if repository is properly configured
        apt policy openlist
        
        # Verify GPG signature (if using signed repository)
        apt-key list | grep -i openlist  # Legacy systems
        gpg --show-keys /usr/share/keyrings/openlist-archive-keyring.gpg  # Modern systems
        \`\`\`

        ### üóëÔ∏è Uninstallation
        \`\`\`bash
        # Stop and remove service
        sudo systemctl stop openlist
        sudo systemctl disable openlist

        # Remove package but keep configuration
        sudo apt remove openlist

        # Remove package and all configuration/data (complete removal)
        sudo apt purge openlist

        # Remove repository configuration
        sudo rm -f /etc/apt/sources.list.d/openlist.sources  # Modern systems
        sudo rm -f /etc/apt/sources.list.d/openlist.list     # Legacy systems
        sudo rm -f /usr/share/keyrings/openlist-archive-keyring.gpg

        # Update package list
        sudo apt update
        \`\`\`

        ### üÜò Troubleshooting
        \`\`\`bash
        # If you get GPG errors
        sudo apt update --allow-unauthenticated
        
        # Re-download GPG key
        curl -fsSL https://github.com/${{ github.repository }}/releases/latest/download/openlist-archive-keyring.gpg | \\
          sudo tee /usr/share/keyrings/openlist-archive-keyring.gpg > /dev/null
        
        # Check service logs for issues
        sudo journalctl -u openlist --no-pager
        
        # Reset configuration (will regenerate on next start)
        sudo systemctl stop openlist
        sudo rm -rf /var/lib/openlist/*
        sudo systemctl start openlist
        \`\`\`

        ---
        **üîí Security Note**: This repository is GPG-signed for package integrity verification. The automatic installation script will set up GPG verification by default. For maximum security, always use the GPG-verified installation methods." \
          openlist-$VERSION-amd64.deb/openlist_${VERSION}-1_amd64.deb \
          openlist-$VERSION-arm64.deb/openlist_${VERSION}-1_arm64.deb \
          $(echo $FILES_TO_UPLOAD | sed 's|^|apt-repo/|g; s| | apt-repo/|g')

  upload-to-ppa:
    name: Upload to PPA Repository
    needs: [check-version, build-deb]
    runs-on: ubuntu-latest
    if: needs.check-version.outputs.should_build == 'true' && vars.ENABLE_PPA_UPLOAD == 'true'
    strategy:
      matrix:
        ubuntu_release: [focal, jammy, noble]  # Ubuntu 20.04, 22.04, 24.04
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up build environment
      run: |
        sudo apt-get update
        sudo apt-get install -y debhelper devscripts build-essential dput jq
        
    - name: Download OpenList source for PPA
      run: |
        VERSION="${{ needs.check-version.outputs.version }}"
        TAG_NAME="${{ needs.check-version.outputs.tag_name }}"
        
        # Ensure version is clean (no 'v' prefix)
        CLEAN_VERSION=$(echo "$VERSION" | sed 's/^v//')
        
        echo "=== Preparing source package for PPA ==="
        echo "VERSION: $VERSION"
        echo "TAG_NAME: $TAG_NAME"
        echo "CLEAN_VERSION: $CLEAN_VERSION"
        
        # Download source code with correct naming for PPA
        echo "Downloading source from: https://github.com/OpenListTeam/OpenList/archive/$TAG_NAME.tar.gz"
        wget -O "openlist_${CLEAN_VERSION}.orig.tar.gz" \
          "https://github.com/OpenListTeam/OpenList/archive/$TAG_NAME.tar.gz"
        
        # Verify the downloaded file
        if [ ! -f "openlist_${CLEAN_VERSION}.orig.tar.gz" ]; then
          echo "Error: Failed to download source archive"
          exit 1
        fi
        
        echo "Downloaded source archive:"
        ls -la openlist_${CLEAN_VERSION}.orig.tar.gz
        
        # Extract and prepare source directory
        tar -xzf "openlist_${CLEAN_VERSION}.orig.tar.gz"
        
        # The extracted directory will be named OpenList-$TAG_NAME (without 'v' prefix)
        EXTRACTED_DIR="OpenList-${TAG_NAME#v}"
        if [ ! -d "$EXTRACTED_DIR" ]; then
          echo "Error: Expected directory $EXTRACTED_DIR not found"
          echo "Available directories:"
          ls -la
          exit 1
        fi
        
        # Rename to match debian package naming convention
        mv "$EXTRACTED_DIR" "openlist-${CLEAN_VERSION}"
        
        echo "Prepared source directory:"
        ls -la openlist-${CLEAN_VERSION}/
        
    - name: Download OpenList binaries for PPA
      run: |
        VERSION="${{ needs.check-version.outputs.version }}"
        TAG_NAME="${{ needs.check-version.outputs.tag_name }}"
        
        # Ensure version is clean (no 'v' prefix)
        CLEAN_VERSION=$(echo "$VERSION" | sed 's/^v//')
        
        echo "=== Downloading OpenList binaries for PPA build ==="
        echo "VERSION: $VERSION"
        echo "TAG_NAME: $TAG_NAME"
        echo "CLEAN_VERSION: $CLEAN_VERSION"
        
        # Enter source directory
        cd openlist-${CLEAN_VERSION}
        
        # Download binaries for both architectures that PPA will need
        for ARCH in amd64 arm64; do
          BINARY_URL="https://github.com/OpenListTeam/OpenList/releases/download/$TAG_NAME/openlist-linux-$ARCH.tar.gz"
          echo "Downloading binary for $ARCH from: $BINARY_URL"
          
          if wget -O "openlist-linux-$ARCH.tar.gz" "$BINARY_URL"; then
            echo "Successfully downloaded openlist-linux-$ARCH.tar.gz"
            echo "File size: $(ls -lh openlist-linux-$ARCH.tar.gz | awk '{print $5}')"
          else
            echo "Error: Failed to download openlist-linux-$ARCH.tar.gz"
            exit 1
          fi
        done
        
        echo "Downloaded binaries:"
        ls -la openlist-linux-*.tar.gz
        
        # Go back to parent directory
        cd ..
        
    - name: Set up GPG
      env:
        GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
      run: |
        echo "$GPG_PRIVATE_KEY" | gpg --batch --import
        echo "use-agent" >> ~/.gnupg/gpg.conf
        echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
        echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
        echo RELOADAGENT | gpg-connect-agent
        
    - name: Build and upload source package to PPA
      env:
        LAUNCHPAD_EMAIL: ${{ secrets.LAUNCHPAD_EMAIL }}
        GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
      run: |
        VERSION="${{ needs.check-version.outputs.version }}"
        TAG_NAME="${{ needs.check-version.outputs.tag_name }}"
        
        # Ensure version is clean (no 'v' prefix)
        CLEAN_VERSION=$(echo "$VERSION" | sed 's/^v//')
        
        # Configure dput for PPA upload
        cat > ~/.dput.cf << EOF
        [ppa]
        fqdn = ppa.launchpad.net
        method = ftp
        incoming = ~openlist/ubuntu/server/
        login = anonymous
        allow_unsigned_uploads = 0
        EOF
        
        # Copy debian directory to source directory
        echo "Copying debian packaging files..."
        cp -r debian openlist-${CLEAN_VERSION}/
        
        # Enter source directory
        cd openlist-${CLEAN_VERSION}
        
        # Update changelog for PPA with clean version and correct distribution
        UBUNTU_RELEASE="${{ matrix.ubuntu_release }}"
        
        # Set version suffix based on Ubuntu release
        case "$UBUNTU_RELEASE" in
          "focal")   VERSION_SUFFIX="1ubuntu1~20.04.1" ;;
          "jammy")   VERSION_SUFFIX="1ubuntu1~22.04.1" ;;
          "noble")   VERSION_SUFFIX="1ubuntu1~24.04.1" ;;
          *)         VERSION_SUFFIX="1ubuntu1" ;;
        esac
        
        echo "Building for Ubuntu $UBUNTU_RELEASE with version suffix: $VERSION_SUFFIX"
        
        cat > debian/changelog << EOF
        openlist ($CLEAN_VERSION-$VERSION_SUFFIX) $UBUNTU_RELEASE; urgency=medium

          * DEB package built from OpenListTeam/OpenList $TAG_NAME
          * Automated build for PPA distribution (Ubuntu $UBUNTU_RELEASE)
          * Binary downloaded from official release

         -- OpenList Team <openlistteam@gmail.com>  $(date -R)
        EOF
        
        # Fix debian/control file - ensure it ends with newline
        if [ -f debian/control ]; then
          # Add newline at end if missing
          sed -i -e '$a\' debian/control
        fi
        
        # Fix debian/rules file - ensure it ends with newline
        if [ -f debian/rules ]; then
          # Add newline at end if missing
          sed -i -e '$a\' debian/rules
          # Make sure it's executable
          chmod +x debian/rules
        fi
        
        # Create a basic debian/copyright file if missing
        if [ ! -f debian/copyright ]; then
          cat > debian/copyright << 'COPYRIGHT_EOF'
        Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
        Upstream-Name: openlist
        Upstream-Contact: OpenList Team <openlistteam@gmail.com>
        Source: https://github.com/OpenListTeam/OpenList

        Files: *
        Copyright: 2025 OpenList Team
        License: AGPL-3.0+

        License: AGPL-3.0+
         This program is free software: you can redistribute it and/or modify
         it under the terms of the GNU Affero General Public License as published
         by the Free Software Foundation, either version 3 of the License, or
         (at your option) any later version.
         .
         This program is distributed in the hope that it will be useful,
         but WITHOUT ANY WARRANTY; without even the implied warranty of
         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
         GNU Affero General Public License for more details.
         .
         You should have received a copy of the GNU Affero General Public License
         along with this program. If not, see <https://www.gnu.org/licenses/>.
         .
         On Debian systems, the complete text of the GNU Affero General Public
         License version 3 can be found in "/usr/share/common-licenses/AGPL-3".
        COPYRIGHT_EOF
        fi
        
        echo "Building source package in directory: $(pwd)"
        echo "Files in current directory:"
        ls -la
        
        # Configure GPG for non-interactive signing in CI environment
        export GPG_TTY=""
        export DEBSIGN_KEYID="$GPG_KEY_ID"
        
        # Create a temporary GPG configuration for signing
        mkdir -p ~/.gnupg
        cat >> ~/.gnupg/gpg.conf << 'GPG_CONF_EOF'
        batch
        no-tty
        pinentry-mode loopback
        GPG_CONF_EOF
        
        # Create a custom debsign wrapper that handles the passphrase
        cat > /tmp/gpg_wrapper.sh << GPG_WRAPPER_EOF
        #!/bin/bash
        echo "$GPG_PASSPHRASE" | gpg --batch --no-tty --pinentry-mode loopback --passphrase-fd 0 "\$@"
        GPG_WRAPPER_EOF
        chmod +x /tmp/gpg_wrapper.sh
        
        # Test the GPG wrapper
        echo "Testing GPG wrapper..."
        echo "test" | /tmp/gpg_wrapper.sh --clearsign > /dev/null 2>&1 || echo "GPG wrapper test completed"
        
        # Set debsign to use our wrapper
        export DEBSIGN_PROGRAM="/tmp/gpg_wrapper.sh"
        
        # Alternative approach: use gpg-preset-passphrase if available
        if command -v gpg-preset-passphrase >/dev/null 2>&1; then
          echo "Using gpg-preset-passphrase..."
          GPG_KEYGRIP=$(gpg --list-secret-keys --with-keygrip | grep -A1 "$GPG_KEY_ID" | grep "Keygrip" | awk '{print $3}')
          if [ -n "$GPG_KEYGRIP" ]; then
            echo "$GPG_PASSPHRASE" | gpg-preset-passphrase --preset "$GPG_KEYGRIP"
          fi
        fi
        
        # Build source package with disabled lintian (using environment variable)
        export DEB_BUILD_OPTIONS="nocheck"
        LINTIAN="" debuild -S -sa -k$GPG_KEY_ID
        
        # Go back to parent directory for upload
        cd ..
        
        echo "Generated files for PPA upload:"
        ls -la openlist_${CLEAN_VERSION}-*
        
        # Find the correct changes file with version suffix
        CHANGES_FILE="openlist_${CLEAN_VERSION}-${VERSION_SUFFIX}_source.changes"
        
        if [ -f "$CHANGES_FILE" ]; then
          echo "Found changes file: $CHANGES_FILE"
          # Upload to PPA
          dput ppa "$CHANGES_FILE"
        else
          echo "Error: Changes file not found: $CHANGES_FILE"
          echo "Available files:"
          ls -la openlist_${CLEAN_VERSION}-*
          exit 1
        fi