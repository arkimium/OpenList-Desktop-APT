name: Build and Upload DEB Package

on:
  schedule:
    # Run daily at 2 AM UTC to check for new releases (updated)
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      force_build:
        description: 'Force build even if no new version'
        required: false
        default: 'false'
        type: boolean
      ppa_build_number:
        description: 'Custom PPA build number (e.g., 2 for 4.0.8-2ubuntu1~22.04.1)'
        required: false
        default: ''
        type: string

permissions:
  contents: write

jobs:
  check-version:
    name: Check OpenList Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      tag_name: ${{ steps.get-version.outputs.tag_name }}
      should_build: ${{ steps.check-build.outputs.should_build }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Get latest OpenList release
      id: get-version
      run: |
        echo "=== Fetching latest release from OpenListTeam/OpenList ==="
        
        # Get latest release info from OpenList repository
        RELEASE_INFO=$(curl -s "https://api.github.com/repos/OpenListTeam/OpenList-Desktop/releases/latest")
        
        echo "API Response:"
        echo "$RELEASE_INFO" | jq '.' || echo "Failed to parse JSON response"
        
        # Extract version and tag name with better error handling
        TAG_NAME=$(echo "$RELEASE_INFO" | jq -r '.tag_name // empty')
        
        if [ -z "$TAG_NAME" ] || [ "$TAG_NAME" = "null" ] || [ "$TAG_NAME" = "empty" ]; then
          echo "Error: Failed to get tag_name from API response"
          echo "Trying alternative approach..."
          
          # Try to get the first release if latest fails
          RELEASE_INFO=$(curl -s "https://api.github.com/repos/OpenListTeam/OpenList-Desktop/releases" | jq '.[0]')
          TAG_NAME=$(echo "$RELEASE_INFO" | jq -r '.tag_name // empty')
          
          if [ -z "$TAG_NAME" ] || [ "$TAG_NAME" = "null" ] || [ "$TAG_NAME" = "empty" ]; then
            echo "Error: Still failed to get tag_name"
            echo "Using fallback version"
            TAG_NAME="v0.6.1"
          fi
        fi
        
        # Remove 'v' prefix if present
        VERSION=${TAG_NAME#v}
        
        # Ensure version is clean (no 'v' prefix)
        VERSION=$(echo "$VERSION" | sed 's/^v//')
        
        # Validate version format
        if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
          echo "Warning: Version format seems invalid: $VERSION"
          echo "Using fallback version"
          VERSION="0.6.1"
          TAG_NAME="v0.6.1"
        fi
        
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Latest OpenList Desktop version: $VERSION (tag: $TAG_NAME)"
        
    - name: Check if build is needed
      id: check-build
      run: |
        VERSION="${{ steps.get-version.outputs.version }}"
        FORCE_BUILD="${{ github.event.inputs.force_build }}"
        
        echo "Checking if build is needed for version: $VERSION"
        
        # Check if this version was already built
        if [ "$FORCE_BUILD" = "true" ]; then
          echo "Force build requested"
          echo "should_build=true" >> $GITHUB_OUTPUT
        else
          # Check if release with this version already exists in current repo
          EXISTING_RELEASE=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/tags/v$VERSION" | jq -r '.tag_name // empty')
          
          if [ -z "$EXISTING_RELEASE" ] || [ "$EXISTING_RELEASE" = "empty" ]; then
            echo "Version $VERSION not found in releases, building..."
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "Version $VERSION already exists, skipping build"
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi
        fi

  build-deb:
    name: Build OpenList Desktop Packages
    needs: check-version
    if: needs.check-version.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [amd64, arm64]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up build environment
      run: |
        sudo apt-get update
        sudo apt-get install -y debhelper devscripts build-essential wget jq
        
        # Install cross-compilation tools for ARM64 if needed
        if [ "${{ matrix.arch }}" = "arm64" ]; then
          sudo apt-get install -y gcc-aarch64-linux-gnu
        fi
        
    - name: Prepare and build DEB package
      run: |
        VERSION="${{ needs.check-version.outputs.version }}"
        TAG_NAME="${{ needs.check-version.outputs.tag_name }}"
        ARCH="${{ matrix.arch }}"
        
        # Validate inputs
        if [ -z "$VERSION" ] || [ "$VERSION" = "null" ]; then
          echo "Error: VERSION is null or empty"
          exit 1
        fi
        
        if [ -z "$TAG_NAME" ] || [ "$TAG_NAME" = "null" ]; then
          echo "Error: TAG_NAME is null or empty"
          exit 1
        fi
        
        # Ensure version is clean (no 'v' prefix) for debian package
        CLEAN_VERSION=$(echo "$VERSION" | sed 's/^v//')
        
        echo "=== Version Information ==="
        echo "Original TAG_NAME: $TAG_NAME"
        echo "Extracted VERSION: $VERSION"
        echo "Clean VERSION for debian: $CLEAN_VERSION"
        echo "Architecture: $ARCH"
        
        # Validate clean version
        if [[ ! "$CLEAN_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
          echo "Error: Clean version format is invalid: $CLEAN_VERSION"
          exit 1
        fi
        
        echo "=== Preparing debian package ==="
        
        # Update changelog with clean version (no 'v' prefix)
        cat > debian/changelog << EOF
        openlist-desktop ($CLEAN_VERSION-1); urgency=medium

          * DEB package built from OpenListTeam/OpenList-Desktop $TAG_NAME
          * Automated build for $ARCH architecture
          * Binary downloaded from official release

         -- Lycaon Constantine Cayde <kamialef2345@gmail.com>, original distributed by OpenList Team <openlistteam@gmail.com>  $(date -R)
        EOF
        
        echo "Generated changelog:"
        cat debian/changelog
        
        # Make scripts executable
        chmod +x debian/rules
        chmod +x debian/postinst
        chmod +x debian/prerm
        chmod +x debian/postrm
        
        echo "=== Pre-downloading binary (optional, debian/rules will download if missing) ==="
        
        # Try to pre-download the binary to speed up build
        DOWNLOAD_URL="https://github.com/OpenListTeam/OpenList-Desktop/releases/download/$TAG_NAME/OpenList-Desktop-$VERSION.tar.gz"
        echo "Pre-download URL: $DOWNLOAD_URL"
        
        if wget -O "openlist-linux-$ARCH.tar.gz" "$DOWNLOAD_URL" 2>/dev/null; then
          echo "Pre-download successful"
          ls -la OpenList-Desktop-$VERSION.tar.gz
        else
          echo "Pre-download failed, debian/rules will handle download"
        fi
        
        echo "=== Building DEB package ==="
        
        # Set environment variables for cross-compilation
        export DEB_HOST_ARCH=$ARCH
        export DEB_BUILD_OPTIONS="nocheck"
        
        # Set cross-compilation environment for ARM64
        if [ "$ARCH" = "arm64" ]; then
          export CC=aarch64-linux-gnu-gcc
          export DEB_BUILD_PROFILES="cross"
        fi
        
        echo "Building package with:"
        echo "DEB_HOST_ARCH=$DEB_HOST_ARCH"
        echo "DEB_BUILD_OPTIONS=$DEB_BUILD_OPTIONS"
        echo "CC=$CC"
        echo "DEB_BUILD_PROFILES=$DEB_BUILD_PROFILES"
        echo "Package version: $CLEAN_VERSION-1"
        
        # Verify current directory before build
        echo "Files in current directory before build:"
        ls -la
        
        # Build the package
        dpkg-buildpackage -us -uc -a$ARCH
        
        echo "=== Build completed ==="
        echo "Generated files:"
        ls -la ../*.deb || echo "No .deb files found in parent directory"
        ls -la *.deb || echo "No .deb files found in current directory"
        
        # The package should be named with the clean version
        EXPECTED_DEB="openlist_${CLEAN_VERSION}-1_${ARCH}.deb"
        if [ -f "$EXPECTED_DEB" ]; then
          echo "Successfully built: $EXPECTED_DEB"
        elif [ -f "../$EXPECTED_DEB" ]; then
          echo "Successfully built: ../$EXPECTED_DEB"
          mv "../$EXPECTED_DEB" "./"
        else
          echo "Warning: Expected DEB file not found: $EXPECTED_DEB"
          echo "Available DEB files:"
          find . -name "*.deb" -o -name "../*.deb"
        fi
        
    - name: Upload DEB artifact to build assets
      uses: actions/upload-artifact@v4
      with:
        name: openlist-${{ needs.check-version.outputs.version }}-${{ matrix.arch }}.deb
        path: openlist_${{ needs.check-version.outputs.version }}-1_${{ matrix.arch }}.deb
        retention-days: 90
        
  create-release:
    name: Create Github Release
    needs: [check-version, build-deb]
    if: needs.check-version.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      
    - name: Set up APT repository tools
      run: |
        sudo apt-get update
        sudo apt-get install -y apt-utils gnupg2
        
    - name: Set up GPG for signing
      env:
        GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
      run: |
        if [ -n "$GPG_PRIVATE_KEY" ]; then
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          echo "use-agent" >> ~/.gnupg/gpg.conf
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          echo RELOADAGENT | gpg-connect-agent
          
          # Get GPG key ID
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -1 | sed 's/.*\/\([A-F0-9]*\).*/\1/')
          echo "GPG_KEY_ID=$GPG_KEY_ID" >> $GITHUB_ENV
          echo "GPG signing enabled with key: $GPG_KEY_ID"
        else
          echo "No GPG key provided, repository will be unsigned"
          echo "GPG_KEY_ID=" >> $GITHUB_ENV
        fi
        
    - name: Generate APT repository files
      run: |
        VERSION="${{ needs.check-version.outputs.version }}"
        
        # Create working directory
        mkdir -p apt-repo
        cd apt-repo
        
        # Copy DEB files
        cp ../Openlist-Desktop-$VERSION-amd64.deb/openlist-desktop_${VERSION}-1_amd64.deb .
        cp ../Openlist-Desktop-$VERSION-arm64.deb/openlist-desktop_${VERSION}-1_arm64.deb .
        
        echo "DEB files for APT repository:"
        ls -la *.deb
        
        # Create apt-ftparchive configuration
        cat > apt-ftparchive.conf << EOF
        APT::FTPArchive::Release::Origin "OpenList Desktop";
        APT::FTPArchive::Release::Label "OpenList Desktop APT Unofficial Repository";
        APT::FTPArchive::Release::Suite "./";
        APT::FTPArchive::Release::Codename "openlist-desktop";
        APT::FTPArchive::Release::Architectures "amd64 arm64";
        APT::FTPArchive::Release::Components "";
        APT::FTPArchive::Release::Description "OpenList Desktop APT Repository for direct GitHub Release access";
        EOF
        
        # Generate Packages file using apt-ftparchive
        apt-ftparchive packages . > Packages
        
        echo "Generated Packages file with $(grep -c '^Package:' Packages) packages"
        
        # Generate Release file using apt-ftparchive
        apt-ftparchive -c apt-ftparchive.conf release . > Release
        
        echo "Generated Release file:"
        cat Release
        
    - name: Sign Release file and create keyring
      env:
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
      run: |
        cd apt-repo
        
        if [ -n "$GPG_KEY_ID" ]; then
          echo "Signing Release file with GPG key: $GPG_KEY_ID"
          
          # Sign Release file (detached signature)
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
              --armor --detach-sign --sign -o Release.gpg Release
          
          # Create InRelease file (clearsigned)
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
              --armor --clearsign --sign -o InRelease Release
          
          echo "Release file signed successfully"
          
          # Export public key and create keyring file
          echo "Creating GPG keyring file..."
          gpg --batch --yes --armor --export "$GPG_KEY_ID" > openlist-desktop-archive-keyring.asc
          gpg --batch --yes --dearmor < openlist-desktop-archive-keyring.asc > openlist-desktop-archive-keyring.gpg
          
          # Verify keyring file
          if [ -f "openlist-desktop-archive-keyring.gpg" ] && [ -s "openlist-desktop-archive-keyring.gpg" ]; then
            echo "GPG keyring file created successfully"
            ls -la openlist-desktop-archive-keyring.*
          else
            echo "Warning: Failed to create GPG keyring file"
          fi
          
          ls -la Release*
        else
          echo "No GPG key available, skipping signing and keyring creation"
        fi
        
    - name: Create installation script
      run: |
        cd apt-repo
        
        # Create installation script
        cat > install-apt.sh << 'EOF'
        #!/bin/bash
        set -e

        # Color definitions for better output
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        BLUE='\033[0;34m'
        PURPLE='\033[0;35m'
        CYAN='\033[0;36m'
        WHITE='\033[1;37m'
        NC='\033[0m' # No Color

        # Logging functions with colors
        log() {
            local message="$1"
            local level="${2:-info}"
            case "$level" in
                "error")
                    echo -e "${RED}[ERROR]${NC} $message" >&2
                    ;;
                "success")
                    echo -e "${GREEN}[SUCCESS]${NC} $message"
                    ;;
                "warning")
                    echo -e "${YELLOW}[WARNING]${NC} $message"
                    ;;
                "info")
                    echo -e "${BLUE}[INFO]${NC} $message"
                    ;;
                *)
                    echo -e "${WHITE}[LOG]${NC} $message"
                    ;;
            esac
        }

        # Error handling function
        handle_error() {
            local exit_code="$1"
            local error_message="$2"
            log "$error_message" "error"
            log "Exit code: $exit_code" "error"
            exit $exit_code
        }

        echo -e "${CYAN}=== OpenList Desktop APT Repository Setup ===${NC}"

        # Detect if running as root
        if [ "$EUID" -eq 0 ]; then
            log "Running as root user" "info"
            SUDO_CMD=""
        else
            log "Running as regular user, will use sudo when needed" "info"
            SUDO_CMD="sudo"
        fi

        # Detect system
        if command -v lsb_release &> /dev/null; then
            DISTRO=$(lsb_release -si)
            VERSION=$(lsb_release -sr)
            log "Detected: $DISTRO $VERSION" "info"
        else
            log "Cannot detect system version, using legacy format" "warning"
            DISTRO="Unknown"
            VERSION="0"
        fi

        # Install required packages for GPG key handling
        log "Installing required packages..." "info"
        if ! $SUDO_CMD apt-get update -qq; then
            handle_error "$?" "Failed to update package list"
        fi

        if ! $SUDO_CMD apt-get install -y -qq curl gnupg2 ca-certificates; then
            handle_error "$?" "Failed to install required packages"
        fi

        # Add GPG key to resolve signature verification issues
        log "Adding OpenList repository GPG key..." "info"
        KEYRING_URL="https://github.com/GITHUB_REPO/releases/latest/download/openlist-desktop-archive-keyring.gpg"
        KEYRING_PATH="/usr/share/keyrings/openlist-desktop-archive-keyring.gpg"
        
        # Try to download the pre-generated keyring file
        if curl -fsSL "$KEYRING_URL" -o /tmp/openlist-desktop-archive-keyring.gpg 2>/dev/null; then
            # Verify the downloaded file is not empty and is a valid GPG keyring
            if [ -s /tmp/openlist-desktop-archive-keyring.gpg ]; then
                $SUDO_CMD mv /tmp/openlist-desktop-archive-keyring.gpg "$KEYRING_PATH"
                $SUDO_CMD chmod 644 "$KEYRING_PATH"
                log "GPG keyring downloaded and installed successfully" "success"
            else
                log "Downloaded keyring file is empty, falling back to trusted repository" "warning"
                rm -f /tmp/openlist-desktop-archive-keyring.gpg
                $SUDO_CMD touch "$KEYRING_PATH"
            fi
        else
            log "Could not download GPG keyring from repository, creating trusted repository entry" "warning"
            # Create a dummy keyring file to avoid errors
            $SUDO_CMD touch "$KEYRING_PATH"
        fi

        # Choose sources format based on system
        if [[ "$DISTRO" == "Ubuntu" && $(echo "$VERSION >= 22.04" | bc -l 2>/dev/null || echo 0) -eq 1 ]] || \
           [[ "$DISTRO" == "Debian" && $(echo "$VERSION >= 12" | bc -l 2>/dev/null || echo 0) -eq 1 ]]; then
            log "Using modern sources format..." "info"
            
            # Use signed-by for modern systems, but fall back to trusted=yes if GPG key is not available
            if [ -s /usr/share/keyrings/openlist-desktop-archive-keyring.gpg ]; then
                echo 'Types: deb
        URIs: https://github.com/GITHUB_REPO/releases/latest/download/
        Suites: ./
        Signed-By: /usr/share/keyrings/openlist-desktop-archive-keyring.gpg' | $SUDO_CMD tee /etc/apt/sources.list.d/openlist-desktop.sources > /dev/null
            else
                echo 'Types: deb
        URIs: https://github.com/GITHUB_REPO/releases/latest/download/
        Suites: ./
        Trusted: yes' | $SUDO_CMD tee /etc/apt/sources.list.d/openlist-desktop.sources > /dev/null
            fi
        else
            log "Using legacy sources format..." "info"
            
            # Use signed-by for legacy systems, but fall back to trusted=yes if GPG key is not available
            if [ -s /usr/share/keyrings/openlist-desktop-archive-keyring.gpg ]; then
                echo 'deb [signed-by=/usr/share/keyrings/openlist-archive-keyring.gpg] https://github.com/GITHUB_REPO/releases/latest/download/ ./' | $SUDO_CMD tee /etc/apt/sources.list.d/openlist.list > /dev/null
            else
                echo 'deb [trusted=yes] https://github.com/GITHUB_REPO/releases/latest/download/ ./' | $SUDO_CMD tee /etc/apt/sources.list.d/openlist.list > /dev/null
            fi
        fi

        log "Repository configuration added successfully" "success"

        # Run 'apt-get update'
        log "Updating package list..." "info"
        if ! $SUDO_CMD apt-get update -y; then
            handle_error "$?" "Failed to run 'apt-get update'"
        else
            log "Repository configured successfully." "success"
            echo ""
            log "To install OpenList Desktop, run: ${WHITE}apt-get install openlist-desktop -y${NC}" "info"
            log "You can also use the following commands:" "info"
            echo ""
            echo -e "${PURPLE}Installation:${NC}"
            if [ "$EUID" -eq 0 ]; then
                echo -e "  ${WHITE}apt-get install openlist-desktop -y${NC}          # Install OpenList Desktop"
            else
                echo -e "  ${WHITE}sudo apt-get install openlist openlist-desktop -y${NC}     # Install OpenList & Desktop Desktop"
            fi
            echo ""
            echo -e "${PURPLE}Service Management (after installation):${NC}"
            if [ "$EUID" -eq 0 ]; then
                echo -e "  ${WHITE}systemctl status openlist${NC}            # Check status"
                echo -e "  ${WHITE}systemctl start openlist${NC}             # Start service"
                echo -e "  ${WHITE}systemctl stop openlist${NC}              # Stop service"
                echo -e "  ${WHITE}systemctl restart openlist${NC}           # Restart service"
                echo -e "  ${WHITE}journalctl -u openlist -f${NC}            # View logs"
            else
                echo -e "  ${WHITE}sudo systemctl status openlist${NC}       # Check status"
                echo -e "  ${WHITE}sudo systemctl start openlist${NC}        # Start service"
                echo -e "  ${WHITE}sudo systemctl stop openlist${NC}         # Stop service"
                echo -e "  ${WHITE}sudo systemctl restart openlist${NC}      # Restart service"
                echo -e "  ${WHITE}sudo journalctl -u openlist -f${NC}       # View logs"
            fi
            echo ""
            echo -e "${PURPLE}Command Line Access (after installation):${NC}"
            echo -e "  ${WHITE}openlist --help${NC}                       # Show help"
            echo -e "  ${WHITE}openlist version${NC}                      # Show version"
            echo ""
            echo -e "${PURPLE}Configuration and Data Location:${NC}"
            echo -e "  ${WHITE}/var/lib/openlist${NC}"
            echo ""
        fi
        EOF
        
        # Replace placeholder with actual repository
        sed -i "s|GITHUB_REPO|${{ github.repository }}|g" install-apt.sh
        chmod +x install-apt.sh

        echo "Created installation script"
        
    - name: Create GitHub Release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        VERSION="${{ needs.check-version.outputs.version }}"
        TAG_NAME="v$VERSION"
        SOURCE_TAG="${{ needs.check-version.outputs.tag_name }}"
        
        # Prepare files for upload
        cd apt-repo
        FILES_TO_UPLOAD="Packages Release install-apt.sh"
        
        # Add signed files if they exist
        if [ -f "Release.gpg" ]; then
          FILES_TO_UPLOAD="$FILES_TO_UPLOAD Release.gpg InRelease"
        fi
        
        # Add keyring file if it exists
        if [ -f "openlist-archive-keyring.gpg" ]; then
          FILES_TO_UPLOAD="$FILES_TO_UPLOAD openlist-archive-keyring.gpg"
        fi
        
        cd ..
        
        # Create release with proper changelog
        gh release create "$TAG_NAME" \
          --title "OpenList DEB Package $VERSION" \
          --notes "## DEB Package for OpenList $VERSION

        This is an automated DEB package build from [OpenListTeam/OpenList $SOURCE_TAG](https://github.com/OpenListTeam/OpenList-Desktop/releases/tag/$SOURCE_TAG).

        ### 📦 Package Information
        - **Source**: OpenListTeam/OpenList-Desktop $SOURCE_TAG
        - **Package Version**: $VERSION-1
        - **Build Date**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        - **Architectures**: AMD64, ARM64
        - **GPG Signed**: $([ -f apt-repo/Release.gpg ] && echo '✅ Yes' || echo '❌ No')
        - **Repository Format**: APT-compatible with GPG signature verification

        ### 🚀 Installation

        #### 🎯 APT Repository (Recommended - Automatic GPG Setup)
        \`\`\`bash
        # One-line install with automatic GPG key setup
        curl -fsSL https://github.com/${{ github.repository }}/releases/latest/download/install-apt.sh | bash
        
        # Then install OpenList
        sudo apt install openlist-desktop -y
        \`\`\`

        #### 📦 PPA Repository (Alternative - Launchpad)
        \`\`\`bash
        # Add PPA repository
        sudo add-apt-repository ppa:wisephaeton/desktop
        sudo apt update
        
        # Install OpenList
        sudo apt install openlist-desktop -y
        \`\`\`

        #### 🔐 Manual APT Setup with GPG Verification (Modern systems - Ubuntu 22.04+/Debian 12+)
        \`\`\`bash
        # Download and install GPG keyring
        curl -fsSL https://github.com/${{ github.repository }}/releases/latest/download/openlist-desktop-archive-keyring.gpg | \\
          sudo tee /usr/share/keyrings/openlist-desktop-archive-keyring.gpg > /dev/null

        # Add repository with GPG verification
        echo \"Types: deb
        URIs: https://github.com/${{ github.repository }}/releases/latest/download/
        Suites: ./
        Signed-By: /usr/share/keyrings/openlist-desktop-archive-keyring.gpg\" | \\
          sudo tee /etc/apt/sources.list.d/openlist-desktop.sources

        # Update and install
        sudo apt update && sudo apt install openlist-desktop -y
        \`\`\`

        #### 🔐 Manual APT Setup with GPG Verification (Legacy systems - Ubuntu <22.04/Debian <12)
        \`\`\`bash
        # Download and install GPG keyring
        curl -fsSL https://github.com/${{ github.repository }}/releases/latest/download/openlist-desktop-archive-keyring.gpg | \\
          sudo tee /usr/share/keyrings/openlist-desktop-archive-keyring.gpg > /dev/null

        # Add repository with GPG verification
        echo \"deb [signed-by=/usr/share/keyrings/openlist-archive-keyring.gpg] https://github.com/${{ github.repository }}/releases/latest/download/ ./\" | \\
          sudo tee /etc/apt/sources.list.d/openlist-desktop.list

        # Update and install
        sudo apt update && sudo apt install openlist-desktop -y
        \`\`\`

        #### ⚠️ Manual APT Setup without GPG Verification (Not Recommended)
        \`\`\`bash
        # Modern systems (Ubuntu 22.04+/Debian 12+)
        echo \"Types: deb
        URIs: https://github.com/${{ github.repository }}/releases/latest/download/
        Suites: ./
        Trusted: yes\" | sudo tee /etc/apt/sources.list.d/openlist-desktop.sources

        # Legacy systems (Ubuntu <22.04/Debian <12)
        echo \"deb [trusted=yes] https://github.com/${{ github.repository }}/releases/latest/download/ ./\" | \\
          sudo tee /etc/apt/sources.list.d/openlist-desktop.list

        # Update and install
        sudo apt update && sudo apt install openlist-desktop -y
        \`\`\`

        #### 📦 Direct Download (AMD64)
        \`\`\`bash
        wget https://github.com/${{ github.repository }}/releases/download/$TAG_NAME/openlist_${VERSION}-1_amd64.deb
        sudo dpkg -i openlist_${VERSION}-1_amd64.deb
        sudo apt-get install -f  # Fix any dependency issues
        \`\`\`

        #### 📦 Direct Download (ARM64)
        \`\`\`bash
        wget https://github.com/${{ github.repository }}/releases/download/$TAG_NAME/openlist_${VERSION}-1_arm64.deb
        sudo dpkg -i openlist-desktop_${VERSION}-1_arm64.deb
        sudo apt-get install -f  # Fix any dependency issues
        \`\`\`

        ### 🔐 GPG Key Information
        - **GPG Signed**: $([ -f apt-repo/Release.gpg ] && echo 'Yes' || echo 'No')
        - **Keyring File**: [openlist-desktop-archive-keyring.gpg](https://github.com/${{ github.repository }}/releases/latest/download/openlist-desktop-archive-keyring.gpg)
        - **Verification**: Repository packages are cryptographically signed for security

        ### 🔧 Service Management
        \`\`\`bash
        # Check service status
        sudo systemctl status openlist

        # Start/stop/restart service
        sudo systemctl start openlist
        sudo systemctl stop openlist
        sudo systemctl restart openlist

        # Enable/disable auto-start
        sudo systemctl enable openlist   # Start on boot
        sudo systemctl disable openlist  # Don't start on boot

        # View logs
        sudo journalctl -u openlist -f
        sudo journalctl -u openlist --since \"1 hour ago\"
        \`\`\`

        ### 📁 File Locations
        - **Binary**: \`/var/lib/openlist/openlist-desktop\`
        - **Working Directory**: \`/var/lib/openlist\`
        - **Service File**: \`/usr/lib/systemd/system/openlist.service\`
        - **Command Symlink**: \`/usr/bin/openlist-desktop\`
        - **Configuration**: \`/var/lib/openlist/\` (auto-generated)
        - **Logs**: \`journalctl -u openlist\` or \`/var/log/syslog\`

        ### 🔍 Verification
        \`\`\`bash
        # Verify installation
        openlist --version
        systemctl is-active openlist
        
        # Check if repository is properly configured
        apt policy openlist-desktop
        
        # Verify GPG signature (if using signed repository)
        apt-key list | grep -i openlist-desktop  # Legacy systems
        gpg --show-keys /usr/share/keyrings/openlist-desktop-archive-keyring.gpg  # Modern systems
        \`\`\`

        ### 🗑️ Uninstallation
        \`\`\`bash
        # Stop and remove service
        sudo systemctl stop openlist
        sudo systemctl disable openlist

        # Remove package but keep configuration
        sudo apt remove openlist

        # Remove package and all configuration/data (complete removal)
        sudo apt purge openlist

        # Remove repository configuration
        sudo rm -f /etc/apt/sources.list.d/openlist-desktop.sources  # Modern systems
        sudo rm -f /etc/apt/sources.list.d/openlist-desktop.list     # Legacy systems
        sudo rm -f /usr/share/keyrings/openlist-desktop-archive-keyring.gpg

        # Update package list
        sudo apt update
        \`\`\`

        ### 🆘 Troubleshooting
        \`\`\`bash
        # If you get GPG errors
        sudo apt update --allow-unauthenticated
        
        # Re-download GPG key
        curl -fsSL https://github.com/${{ github.repository }}/releases/latest/download/openlist-archive-keyring.gpg | \\
          sudo tee /usr/share/keyrings/openlist-desktop-archive-keyring.gpg > /dev/null
        
        # Check service logs for issues
        sudo journalctl -u openlist --no-pager
        
        # Reset configuration (will regenerate on next start)
        sudo systemctl stop openlist
        sudo rm -rf /var/lib/openlist/*
        sudo systemctl start openlist
        \`\`\`

        ---
        **🔒 Security Note**: This repository is GPG-signed for package integrity verification. The automatic installation script will set up GPG verification by default. For maximum security, always use the GPG-verified installation methods." \
          OpenList-Desktop-$VERSION-amd64.deb/openList-desktop_${VERSION}-1_amd64.deb \
          Openlist-Desktop-$VERSION-arm64.deb/openlist-desktop_${VERSION}-1_arm64.deb \
          $(echo $FILES_TO_UPLOAD | sed 's|^|apt-repo/|g; s| | apt-repo/|g')

  upload-to-ppa:
    name: Upload to PPA Repository
    needs: [check-version, build-deb]
    runs-on: ubuntu-latest
    if: needs.check-version.outputs.should_build == 'true' && vars.ENABLE_PPA_UPLOAD == 'true'
    strategy:
      matrix:
        ubuntu_release: [focal, jammy, noble]  # Ubuntu 20.04, 22.04, 24.04
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up build environment
      run: |
        sudo apt-get update
        sudo apt-get install -y debhelper devscripts build-essential dput jq
        
    - name: Prepare minimal source package for PPA
      run: |
        VERSION="${{ needs.check-version.outputs.version }}"
        TAG_NAME="${{ needs.check-version.outputs.tag_name }}"
        
        # Ensure version is clean (no 'v' prefix)
        CLEAN_VERSION=$(echo "$VERSION" | sed 's/^v//')
        
        echo "=== Preparing minimal source package for PPA ==="
        echo "VERSION: $VERSION"
        echo "TAG_NAME: $TAG_NAME"
        echo "CLEAN_VERSION: $CLEAN_VERSION"
        
        # Create minimal source directory structure (no need to download full OpenList source)
        mkdir -p "openlist-desktop-${CLEAN_VERSION}"
        cd "openlist-desktop-${CLEAN_VERSION}"
        
        # Create minimal source files required for PPA
        echo "Creating minimal source structure..."
        
        # Create a minimal README
        cat > README.md << 'EOF'
        # OpenList DEB Package
        
        This is a minimal source package for building OpenList DEB packages.
        The actual OpenList binaries are downloaded from the official releases.
        EOF
        
        # Create a minimal Makefile (required for debian source packages)
        cat > Makefile << 'EOF'
        # Minimal Makefile for OpenList DEB package
        # The actual build is handled by debian/rules
        
        all:
        	@echo "OpenList DEB package - build handled by debian/rules"
        
        install:
        	@echo "Install handled by debian/rules"
        
        clean:
        	@echo "Clean handled by debian/rules"
        
        .PHONY: all install clean
        EOF
        
        # Download binaries for both architectures that PPA will need
        echo "=== Downloading OpenList Desktop binaries ==="
        mkdir -p debian/binaries
        
        for ARCH in amd64 arm64; do
          BINARY_URL="https://github.com/OpenListTeam/OpenList-Desktop/releases/download/$TAG_NAME/OpenList-Desktop-$ARCH.tar.gz"
          echo "Downloading binary for $ARCH..."
          echo "URL: $BINARY_URL"
          
          # Use wget with progress bar instead of verbose output to reduce log spam
          if wget --progress=bar:force:noscroll -O "debian/binaries/OpenList-Desktop-linux-$ARCH.tar.gz" "$BINARY_URL" 2>&1; then
            echo "✅ Successfully downloaded OpenList-Desktop$ARCH.tar.gz"
            FILE_SIZE=$(ls -lh debian/binaries/OpenList-Desktop-$ARCH.tar.gz | awk '{print $5}')
            echo "📦 File size: $FILE_SIZE"
            
            # Verify the file is not empty
            if [ ! -s "debian/binaries/OpenList-Desktop-$ARCH.tar.gz" ]; then
              echo "❌ Error: Downloaded file is empty"
              exit 1
            fi
          else
            echo "❌ Error: Failed to download OpenList-Desktop-$ARCH.tar.gz"
            exit 1
          fi
          
          echo "---"
        done
        
        echo "=== Download Summary ==="
        echo "Downloaded binaries:"
        ls -la debian/binaries/
        
        # Go back to parent directory
        cd ..
        
        # Create the orig.tar.gz from our minimal source (required for PPA)
        echo "Creating orig.tar.gz from minimal source..."
        tar -czf "openlist-desktop_${CLEAN_VERSION}.orig.tar.gz" "openlist-desktop-${CLEAN_VERSION}"
        
        echo "Created minimal source package:"
        ls -la openlist-desktop_${CLEAN_VERSION}.orig.tar.gz
        
    - name: Set up GPG
      env:
        GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
      run: |
        # Create GPG directory with proper permissions
        mkdir -p ~/.gnupg
        chmod 700 ~/.gnupg
        
        # Import GPG private key
        echo "$GPG_PRIVATE_KEY" | gpg --batch --import
        
        # Configure GPG for non-interactive use in CI
        cat > ~/.gnupg/gpg.conf << 'GPG_CONF_EOF'
        use-agent
        pinentry-mode loopback
        batch
        no-tty
        GPG_CONF_EOF
        
        cat > ~/.gnupg/gpg-agent.conf << 'GPG_AGENT_CONF_EOF'
        allow-loopback-pinentry
        default-cache-ttl 7200
        max-cache-ttl 7200
        GPG_AGENT_CONF_EOF
        
        # Restart GPG agent
        gpgconf --reload gpg-agent
        
        # Test GPG configuration
        echo "Testing GPG configuration..."
        echo "test" | gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --clearsign > /dev/null 2>&1
        
        if [ $? -eq 0 ]; then
          echo "✅ GPG configuration test successful"
        else
          echo "❌ GPG configuration test failed"
          exit 1
        fi
        
    - name: Build and upload source package to PPA
      env:
        LAUNCHPAD_EMAIL: ${{ secrets.LAUNCHPAD_EMAIL }}
        GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
      run: |
        VERSION="${{ needs.check-version.outputs.version }}"
        TAG_NAME="${{ needs.check-version.outputs.tag_name }}"
        
        # Ensure version is clean (no 'v' prefix)
        CLEAN_VERSION=$(echo "$VERSION" | sed 's/^v//')
        
        # Configure dput for PPA upload
        cat > ~/.dput.cf << EOF
        [ppa]
        fqdn = ppa.launchpad.net
        method = ftp
        incoming = ~wisephaeton/ubuntu/desktop/
        login = anonymous
        allow_unsigned_uploads = 0
        EOF
        
        # Copy debian directory to source directory
        echo "Copying debian packaging files..."
        cp -r debian openlist-desktop-${CLEAN_VERSION}/
        
        # Verify that pre-downloaded binaries are in the source package
        echo "Verifying pre-downloaded binaries in source package..."
        if [ -d "openlist-desktop-${CLEAN_VERSION}/debian/binaries" ]; then
          echo "✅ Binaries found in source package:"
          ls -la openlist-desktop-${CLEAN_VERSION}/debian/binaries/
        else
          echo "❌ No binaries found in source package - this should not happen"
          echo "Contents of source directory:"
          ls -la openlist-desktop-${CLEAN_VERSION}/
          echo "Contents of debian directory:"
          ls -la openlist-desktop-${CLEAN_VERSION}/debian/
          exit 1
        fi
        
        # Enter source directory
        cd openlist-desktop-${CLEAN_VERSION}
        
        # Update changelog for PPA with clean version and correct distribution
        UBUNTU_RELEASE="${{ matrix.ubuntu_release }}"
        
        # Get the next available version suffix
        echo "Getting next available PPA version for $CLEAN_VERSION on $UBUNTU_RELEASE..."
        
        # Check if user provided custom PPA build number
        CUSTOM_PPA_BUILD="${{ github.event.inputs.ppa_build_number }}"
        
        case "$UBUNTU_RELEASE" in
          "focal")   BASE_SUFFIX="ubuntu1~20.04.1" ;;
          "jammy")   BASE_SUFFIX="ubuntu1~22.04.1" ;;
          "noble")   BASE_SUFFIX="ubuntu1~24.04.1" ;;
          *)         BASE_SUFFIX="ubuntu1" ;;
        esac
        
        if [ -n "$CUSTOM_PPA_BUILD" ] && [ "$CUSTOM_PPA_BUILD" != "" ]; then
          # User provided custom build number
          echo "=== Using custom PPA build number: $CUSTOM_PPA_BUILD ==="
          REVISION_NUMBER="$CUSTOM_PPA_BUILD"
          VERSION_SUFFIX="${REVISION_NUMBER}${BASE_SUFFIX}"
          TEST_FULL_VERSION="${CLEAN_VERSION}-${VERSION_SUFFIX}"
          
          echo "Custom version will be: $TEST_FULL_VERSION"
          
          # Check if this custom version already exists (warn but continue)
          DSC_URL="https://ppa.launchpadcontent.net/wisephaeton/desktop/ubuntu/pool/main/o/openlist-desktop/openlist-desktop_${TEST_FULL_VERSION}.dsc"
          if curl -s --head "$DSC_URL" | grep -q "200 OK"; then
            echo "⚠️  WARNING: Custom version $TEST_FULL_VERSION already exists in PPA!"
            echo "⚠️  This upload may fail or overwrite the existing package."
            echo "⚠️  Consider using a different build number."
          else
            echo "✅ Custom version $TEST_FULL_VERSION appears to be available."
          fi
        else
          # Auto-detect next available version
          echo "=== Auto-detecting next available PPA version ==="
          REVISION_NUMBER=1
          
          # 连续检测版本，确保找到真正可用的版本
          while true; do
            VERSION_SUFFIX="${REVISION_NUMBER}${BASE_SUFFIX}"
            TEST_FULL_VERSION="${CLEAN_VERSION}-${VERSION_SUFFIX}"
            
            echo "=== Checking version $REVISION_NUMBER: $TEST_FULL_VERSION ==="
            
            # 使用多种方法检测版本是否存在
            VERSION_EXISTS=false
            
            # 方法1: 检查.dsc文件
            DSC_URL="https://ppa.launchpadcontent.net/wisephaeton/desktop/ubuntu/pool/main/o/openlist-desktop/openlist-desktop_${TEST_FULL_VERSION}.dsc"
            echo "Method 1: Checking .dsc file..."
            if curl -s --head "$DSC_URL" | grep -q "200 OK"; then
              echo "Found .dsc file - version $TEST_FULL_VERSION exists"
              VERSION_EXISTS=true
            else
              echo "No .dsc file found"
            fi
            
            # 方法2: 检查Launchpad API (如果方法1没有发现)
            if [ "$VERSION_EXISTS" = false ]; then
              echo "Method 2: Checking Launchpad API..."
              API_URL="https://api.launchpad.net/1.0/~wisephaeton/+archive/ubuntu/desktop"
              API_RESPONSE=$(curl -s "${API_URL}?ws.op=getPublishedSources&source_name=openlist&distro_series=/ubuntu/${UBUNTU_RELEASE}" 2>/dev/null || echo "")
              
              if echo "$API_RESPONSE" | grep -q "\"version\": \"$TEST_FULL_VERSION\""; then
                echo "Found in Launchpad API - version $TEST_FULL_VERSION exists"
                VERSION_EXISTS=true
              else
                echo "Not found in Launchpad API"
              fi
            fi
            
            # 判断版本是否可用
            if [ "$VERSION_EXISTS" = true ]; then
              echo "Version $TEST_FULL_VERSION is OCCUPIED, trying next revision..."
              REVISION_NUMBER=$((REVISION_NUMBER + 1))
              
              # 安全检查
              if [ $REVISION_NUMBER -gt 50 ]; then
                echo "ERROR: Too many revision attempts (>50), something might be wrong"
                exit 1
              fi
              
              echo "Moving to revision $REVISION_NUMBER..."
              sleep 1
              # 继续循环检测下一个版本
            else
              echo "Version $TEST_FULL_VERSION is AVAILABLE!"
              echo "Final decision: Using version $TEST_FULL_VERSION"
              break
            fi
          done
        fi
        
        if [ -z "$VERSION_SUFFIX" ]; then
          echo "Error: Failed to determine version suffix"
          exit 1
        fi
        
        echo "Using version suffix: $VERSION_SUFFIX"
        echo "Full package version will be: $CLEAN_VERSION-$VERSION_SUFFIX"
        
        cat > debian/changelog << EOF
        openlist-desktop ($CLEAN_VERSION-$VERSION_SUFFIX) $UBUNTU_RELEASE; urgency=medium

          * DEB package built from OpenListTeam/OpenList-Desktop $TAG_NAME
          * Automated build for PPA distribution (Ubuntu $UBUNTU_RELEASE)
          * Binary downloaded from official release

         -- Lycaon Constantine Cayde <kamialef2345@gmail.com>, original distributed by OpenList Team <openlistteam@gmail.com>  $(date -R)
        EOF
        
        # Fix debian/control file - ensure it ends with newline
        if [ -f debian/control ]; then
          # Add newline at end if missing
          sed -i -e '$a\' debian/control
        fi
        
        # Fix debian/rules file - ensure it ends with newline
        if [ -f debian/rules ]; then
          # Add newline at end if missing
          sed -i -e '$a\' debian/rules
          # Make sure it's executable
          chmod +x debian/rules
        fi
        
        # Create a basic debian/copyright file if missing
        if [ ! -f debian/copyright ]; then
          cat > debian/copyright << 'COPYRIGHT_EOF'
        Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
        Upstream-Name: openlist-desktop
        Upstream-Contact: OpenList Team <openlistteam@gmail.com>
        Source: https://github.com/OpenListTeam/OpenList-Desktop

        Files: *
        Copyright: 2025 Lycaon Constantine Cayde, originally produce by OpenList Team
        License: AGPL-3.0+

        License: AGPL-3.0+
         This program is free software: you can redistribute it and/or modify
         it under the terms of the GNU Affero General Public License as published
         by the Free Software Foundation, either version 3 of the License, or
         (at your option) any later version.
         .
         This program is distributed in the hope that it will be useful,
         but WITHOUT ANY WARRANTY; without even the implied warranty of
         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
         GNU Affero General Public License for more details.
         .
         You should have received a copy of the GNU Affero General Public License
         along with this program. If not, see <https://www.gnu.org/licenses/>.
         .
         On Debian systems, the complete text of the GNU Affero General Public
         License version 3 can be found in "/usr/share/common-licenses/AGPL-3".
        COPYRIGHT_EOF
        fi
        
        echo "Building source package in directory: $(pwd)"
        echo "Files in current directory:"
        ls -la
        
        # Configure GPG for non-interactive signing in CI environment
        export GPG_TTY=""
        export DEBSIGN_KEYID="$GPG_KEY_ID"
        
        # Create a temporary GPG configuration for signing
        mkdir -p ~/.gnupg
        cat >> ~/.gnupg/gpg.conf << 'GPG_CONF_EOF'
        batch
        no-tty
        pinentry-mode loopback
        GPG_CONF_EOF
        
        # Create a custom debsign wrapper that handles the passphrase
        cat > /tmp/gpg_wrapper.sh << GPG_WRAPPER_EOF
        #!/bin/bash
        echo "$GPG_PASSPHRASE" | gpg --batch --no-tty --pinentry-mode loopback --passphrase-fd 0 "\$@"
        GPG_WRAPPER_EOF
        chmod +x /tmp/gpg_wrapper.sh
        
        # Test the GPG wrapper
        echo "Testing GPG wrapper..."
        echo "test" | /tmp/gpg_wrapper.sh --clearsign > /dev/null 2>&1 || echo "GPG wrapper test completed"
        
        # Set debsign to use our wrapper
        export DEBSIGN_PROGRAM="/tmp/gpg_wrapper.sh"
        
        # Alternative approach: use gpg-preset-passphrase if available
        if command -v gpg-preset-passphrase >/dev/null 2>&1; then
          echo "Using gpg-preset-passphrase..."
          GPG_KEYGRIP=$(gpg --list-secret-keys --with-keygrip | grep -A1 "$GPG_KEY_ID" | grep "Keygrip" | awk '{print $3}')
          if [ -n "$GPG_KEYGRIP" ]; then
            echo "$GPG_PASSPHRASE" | gpg-preset-passphrase --preset "$GPG_KEYGRIP"
          fi
        fi
        
        # Build source package with disabled lintian (using environment variable)
        export DEB_BUILD_OPTIONS="nocheck"
        
        echo "=== Building source package with debuild ==="
        echo "GPG_KEY_ID: $GPG_KEY_ID"
        echo "DEBSIGN_KEYID: $DEBSIGN_KEYID"
        echo "DEBSIGN_PROGRAM: $DEBSIGN_PROGRAM"
        
        # Use debuild with explicit GPG configuration
        if ! LINTIAN="" debuild -S -sa -k$GPG_KEY_ID; then
          echo "❌ debuild failed, checking for common issues..."
          
          # Check if GPG key is available
          if ! gpg --list-secret-keys "$GPG_KEY_ID" >/dev/null 2>&1; then
            echo "❌ GPG key $GPG_KEY_ID not found in keyring"
            echo "Available keys:"
            gpg --list-secret-keys
            exit 1
          fi
          
          # Try alternative signing approach
          echo "🔄 Trying alternative signing approach..."
          
          # Build unsigned first
          if dpkg-buildpackage -S -sa -us -uc; then
            echo "✅ Unsigned source package built successfully"
            
            # Sign manually
            echo "🔐 Signing source package manually..."
            cd ..
            
            DSC_FILE="openlist-desktop_${CLEAN_VERSION}-${VERSION_SUFFIX}.dsc"
            CHANGES_FILE="openlist-desktop_${CLEAN_VERSION}-${VERSION_SUFFIX}_source.changes"
            
            if [ -f "$DSC_FILE" ] && [ -f "$CHANGES_FILE" ]; then
              # Sign .dsc file
              if gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
                     --armor --detach-sign --sign "$DSC_FILE"; then
                echo "✅ .dsc file signed successfully"
              else
                echo "❌ Failed to sign .dsc file"
                exit 1
              fi
              
              # Sign .changes file
              if gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
                     --armor --detach-sign --sign "$CHANGES_FILE"; then
                echo "✅ .changes file signed successfully"
              else
                echo "❌ Failed to sign .changes file"
                exit 1
              fi
            else
              echo "❌ Required files not found: $DSC_FILE, $CHANGES_FILE"
              exit 1
            fi
            
            cd openlist-desktop-${CLEAN_VERSION}
          else
            echo "❌ Even unsigned build failed"
            exit 1
          fi
        else
          echo "✅ debuild completed successfully"
          cd ..
        fi
        
        echo "=== Verifying generated files ==="
        echo "Generated files for PPA upload:"
        ls -la openlist-desktop_${CLEAN_VERSION}-*
        
        # Find the correct changes file with version suffix
        CHANGES_FILE="openlist-desktop_${CLEAN_VERSION}-${VERSION_SUFFIX}_source.changes"
        DSC_FILE="openlist-desktop_${CLEAN_VERSION}-${VERSION_SUFFIX}.dsc"
        
        # Verify files exist
        if [ ! -f "$CHANGES_FILE" ]; then
          echo "❌ Changes file not found: $CHANGES_FILE"
          echo "Available files:"
          ls -la openlist-desktop_${CLEAN_VERSION}-*
          exit 1
        fi
        
        if [ ! -f "$DSC_FILE" ]; then
          echo "❌ DSC file not found: $DSC_FILE"
          echo "Available files:"
          ls -la openlist-desktop_${CLEAN_VERSION}-*
          exit 1
        fi
        
        # Verify GPG signatures
        echo "=== Verifying GPG signatures ==="
        
        echo "Verifying $CHANGES_FILE signature..."
        if gpg --verify "$CHANGES_FILE" 2>&1; then
          echo "✅ $CHANGES_FILE signature verified"
        else
          echo "❌ $CHANGES_FILE signature verification failed"
          echo "File contents:"
          head -20 "$CHANGES_FILE"
          exit 1
        fi
        
        echo "Verifying $DSC_FILE signature..."
        if gpg --verify "$DSC_FILE" 2>&1; then
          echo "✅ $DSC_FILE signature verified"
        else
          echo "❌ $DSC_FILE signature verification failed"
          echo "File contents:"
          head -20 "$DSC_FILE"
          exit 1
        fi
        
        echo "=== Uploading to PPA ==="
        echo "Found changes file: $CHANGES_FILE"
        
        # Upload to PPA with verbose output
        if dput -f ppa "$CHANGES_FILE"; then
          echo "✅ Successfully uploaded to PPA"
        else
          echo "❌ PPA upload failed"
          echo "Checking dput configuration..."
          cat ~/.dput.cf
          echo "Checking changes file content..."
          cat "$CHANGES_FILE"
          exit 1
        fi
